#+title: Refactor of Config
#+property: header-args:emacs-lisp :tangle yes :comments link
#+property: header-args :tangle no :results silent :eval no-export
#+startup: fold

* Context
This section serves mostly to explain what the rest of the config is, how it's set up, and how to configure emacs. I'm really not comfortable with e-lisp, so I don't really want to write a config from scratch that will work for everything I need. As such, I run a configuration framework for emacs. I tried spacemacs, but hated how much everything was abstracted away from me, and the seemingly arbitrary conventions about how you should configure your own config. I then tried Doom, and it seems much better because it lets one do things in any way they want, and all of doom's features can be enabled or disabled at will. Because of this, I can go from either a performant vanilla with a cli, or a full featured IDE with support for things like email by changing only 50 LOC or so.

Nearly all of the code here tangles directly into =$DOOMDIR/config.org=. For some reason, emacs performs better when lexical is binding is used on this file, so...
#+begin_src emacs-lisp :comments no
;;; config.el -*- lexical binding: t; -*-
#+end_src
* Basic Config
** Simple Settings
From looking at other people's configs, these are the basic options that I have decided upon.
#+begin_src emacs-lisp
(setq!
delete-by-moving-to-trash t                      ; Delete files to trash
window-combination-resize t                      ; take new window space from all other windows (not just current)
x-stretch-cursor t)                              ; Stretch cursor to the glyph width
(setq! undo-limit 80000000                         ; Raise undo-limit to 80Mb
      evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t                         ; Nobody likes to loose work, I certainly don't
      truncate-string-ellipsis "…")               ; Unicode ellispis are nicer than "...", and also save /precious/ space
(display-time-mode 1)                             ; Enable time in the mode-line
(if (equal "Battery status not available"
          (battery))
(display-battery-mode 1)                        ; On laptops it's nice to know how much power you have
(setq! password-cache-expiry nil))               ; I can trust my desktops ... can't I? (no battery = desktop)
(global-subword-mode 1)                           ; Iterate through CamelCase words
(setq! auth-sources '("~/.local/share/authinfo.gpg")
     auth-source-cache-expiry 3600)
#+end_src
** Auto-customization
By default, the =M-x customize= interface will put the variables into =init.el=, which is frankly disgusting. Instead, the customized variables should be put in a separate file that is not tracked by git.
#+begin_src emacs-lisp
(setq! custom-file (expand-file-name "custom.el" doom-private-dir))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src
** Splits
Yes, Emacs has a bizarre terminology for it's graphical elements. Any open file or text object is a buffer, each visible buffer is displayed in a split, and the over-arching window that is managed by your WM is a frame.
By default, emacs chooses create splits almost arbitrarily, so make it more sensible.
#+begin_src emacs-lisp
(setq! evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

When a split is created, it would be preferable to preview the open buffers and decide which buffer to open.
First, a buffer prompt has to be opened.
#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
    :after '(evil-window-split evil-window-vsplit)
    (consult-buffer))
#+end_src

Window rotation is a doom default, but /layout/ rotation is not. This snippet adds =SPC w SPC= to rotate windows, and arrow key analogs of =hjkl= in the rare even I use them.
#+begin_src emacs-lisp
(map! :map evil-window-map
      "SPC" #'rotate-layout
      ;; navigation
      "<left>" #'evil-window-left
      "<down>" #'evil-window-down
      "<up>" #'evil-window-up
      "<right>" #'evil-window-right
      ;; Swapping windows
      "S-<left>" #'+evil/window-move-left
      "S-<down>" #'+evil/window-move-down
      "S-<up>" #'+evil/window-move-up
      "S-<right>" #'+evil/window-move-right)
#+end_src
** Buffer Defaults
Emacs opens any new buffer in =fundamental-mode=. This is the mode that all other major-modes derive from, but it does nothing by itself. I would much rather open buffers in a mode I actually use, like org.
#+begin_src emacs-lisp
(setq! major-mode 'org-mode)
#+end_src

I'd like some nicer buffer names, too.
#+begin_src emacs-lisp
(setq! doom-fallback-buffer-name "► Doom"
      +doom-dashboard-name "► Doom")
#+end_src
** UI
*** Fonts
My favorite font for programming is by far ~JetBrains Mono~, and ~Overpass~ works pretty well as a san-serif companion. These fonts don't seem to support unicode though, so ~DejaVuSerif~ is used for that. Finally, for my /fancy/ writings, ~IBM Plex~ is a nice serif font. Sadly, none of these fonts seem to match up with each other, so they all require different sizes.
#+begin_src emacs-lisp
(setq! all-the-icons-scale-factor 1.1)
(setq! doom-font (font-spec :family "JetBrainsMono Nerd Font" :size 12)
      doom-variable-pitch-font (font-spec :family "Overpass")
      doom-big-font (font-spec :family "JetBrainsMono Nerd Font" :size 17)
      doom-unicode-font (font-spec :family "DejaVuSerif")
      doom-serif-font (font-spec :family "IBM Plex Mono" :weight 'light))
#+end_src
In addition, ~Merriweather~ is used for specific major modes, and ~Cantarell~ is used in all the aesthetic modes.

If any of these fonts are missing at startup, Doom has some serious issues. Consequently, it's helpful to remind the user if these fonts are missing.
#+name: detect-missing-fonts
#+begin_src emacs-lisp :tangle no
(defvar required-fonts '("JetBrainsMono.*" "Overpass" "DejaVuSerif" "IBM Plex Mono" "Merriweather" "Cantarell"))

(defvar available-fonts
  (delete-dups (or (font-family-list)
                   (split-string (shell-command-to-string "fc-list : family")
                                 "[,\n]"))))

(defvar missing-fonts
  (delq nil (mapcar
             (lambda (font)
               (unless (delq nil (mapcar (lambda (f)
                                           (string-match-p (format "^%s$" font) f))
                                         available-fonts))
                 font))
             required-fonts)))

(if missing-fonts
    (pp-to-string
     `(unless noninteractive
        (add-hook! 'doom-init-ui-hook
          (run-at-time nil nil
                       (lambda ()
                         (message "%s missing the following fonts: %s"
                                  (propertize "Warning!" 'face '(bold warning))
                                  (mapconcat (lambda (font)
                                               (propertize font 'face 'font-lock-variable-name-face))
                                             ',missing-fonts
                                             ", "))
                         (sleep-for 0.5))))))
  ";; No missing fonts detected")
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<detect-missing-fonts>>
#+end_src
*** Theme and Modeline
=doom-one=, the default theme for doom, is nice, but it's too blue for my taste. The best theme I have found in the =doom-themes= package would be =gruvbox-dark=, so let's load that. Oh, and why not make it easier to load themes in the future?
#+begin_src emacs-lisp
(setq doom-theme 'doom-gruvbox
      doom-gruvbox-dark-variant "hard"
      doom-gruvbox-brighter-comments t)
(delq! t custom-theme-load-path)
(map! :leader
      :desc "Load new themes" "t h" #'counsel-load-theme)
#+end_src

Because I use the daemon for everything, the modeline assumes that I don't want icons. I do.
#+begin_src emacs-lisp
(setq doom-modeline-icon t)
#+end_src
While we're making the modeline less trash, why don't we remove information that's almost always the same, like line-endings or encoding?
#+begin_src emacs-lisp
(defun doom-modeline-conditional-buffer-encoding ()
  "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
  (setq-local doom-modeline-buffer-encoding
              (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                 '(coding-category-undecided coding-category-utf-8))
                           (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                t)))

(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
#+end_src
*** Line Numbers
The utility of seeing exactly how many lines away something is is invaluable to me.
#+begin_src emacs-lisp
(setq! display-line-numbers-type 'relative)
#+end_src
*** Window Title
Instead of saying "doom emacs," the title for the window should really be what we're editing, and what project that's in.
#+begin_src emacs-lisp
(setq! frame-title-format
      '(""
        (:eval
         (if (s-contains-p org-roam-directory (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "☰ "
              (subst-char-in-string ?_ ?  buffer-file-name))
           "%b"))
        (:eval
         (let ((project-name (projectile-project-name)))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p)  " ◉ %s" "  ●  %s") project-name))))))
#+end_src
*** Splash Screen
Emacs, at least when ran in as a GUI, is capable of rendering images. As such, why not make the splash screen use this.
#+begin_src emacs-lisp
(defvar fancy-splash-image-template
  (expand-file-name "misc/splash-images/emacs-e-template.svg" doom-private-dir)
  "Default template svg used for the splash image, with substitutions from ")

(defvar fancy-splash-sizes
  `((:height 300 :min-height 50 :padding (0 . 2))
    (:height 250 :min-height 42 :padding (2 . 4))
    (:height 200 :min-height 35 :padding (3 . 3))
    (:height 150 :min-height 28 :padding (3 . 3))
    (:height 100 :min-height 20 :padding (2 . 2))
    (:height 75  :min-height 15 :padding (2 . 1))
    (:height 50  :min-height 10 :padding (1 . 0))
    (:height 1   :min-height 0  :padding (0 . 0)))
  "list of plists with the following properties
  :height the height of the image
  :min-height minimum `frame-height' for image
  :padding `+doom-dashboard-banner-padding' (top . bottom) to apply
  :template non-default template file
  :file file to use instead of template")

(defvar fancy-splash-template-colors
  '(("$color1" . keywords) ("$colour2" . type) ("$colour3" . base5) ("$colour4" . base8))
  "list of color-replacement alists of the form (\"$placeholder\" . 'theme-colour) which applied the template")

(unless (file-exists-p (expand-file-name "theme-splashes" doom-cache-dir))
  (make-directory (expand-file-name "theme-splashes" doom-cache-dir) t))

(defun fancy-splash-filename (theme-name height)
  (expand-file-name (concat (file-name-as-directory "theme-splashes")
                            theme-name
                            "-" (number-to-string height) ".svg")
                    doom-cache-dir))

(defun fancy-splash-clear-cache ()
  "Delete all cached fancy splash images"
  (interactive)
  (delete-directory (expand-file-name "theme-splashes" doom-cache-dir) t)
  (message "Cache cleared!"))

(defun fancy-splash-generate-image (template height)
  "Read TEMPLATE and create an image if HEIGHT with color substitutions as
   described by `fancy-splash-template-colors' for the current theme"
  (with-temp-buffer
    (insert-file-contents template)
    (re-search-forward "$height" nil t)
    (replace-match (number-to-string height) nil nil)
    (dolist (substitution fancy-splash-template-colors)
      (goto-char (point-min))
      (while (re-search-forward (car substitution) nil t)
        (replace-match (doom-color (cdr substitution)) nil nil)))
    (write-region nil nil
                  (fancy-splash-filename (symbol-name doom-theme) height) nil nil)))

(defun fancy-splash-generate-images ()
  "Perform `fancy-splash-generate-image' in bulk"
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (fancy-splash-generate-image (or (plist-get size :template)
                                       fancy-splash-image-template)
                                   (plist-get size :height)))))

(defun ensure-theme-splash-images-exist (&optional height)
  (unless (file-exists-p (fancy-splash-filename
                          (symbol-name doom-theme)
                          (or height
                              (plist-get (car fancy-splash-sizes) :height))))
    (fancy-splash-generate-images)))

(defun get-appropriate-splash ()
  (let ((height (frame-height)))
    (cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
             fancy-splash-sizes)))

(setq! fancy-splash-last-size nil)
(setq! fancy-splash-last-theme nil)
(defun set-appropriate-splash (&rest _)
  (let ((appropriate-image (get-appropriate-splash)))
    (unless (and (equal appropriate-image fancy-splash-last-size)
                 (equal doom-theme fancy-splash-last-theme)))
    (unless (plist-get appropriate-image :file)
      (ensure-theme-splash-images-exist (plist-get appropriate-image :height)))
    (setq! fancy-splash-image
          (or (plist-get appropriate-image :file)
              (fancy-splash-filename (symbol-name doom-theme) (plist-get appropriate-image :height))))
    (setq! +doom-dashboard-banner-padding (plist-get appropriate-image :padding))
    (setq! fancy-splash-last-size appropriate-image)
    (setq! fancy-splash-last-theme doom-theme)
    (+doom-dashboard-reload)))

(add-hook 'window-size-change-functions #'set-appropriate-splash)
(add-hook 'doom-load-theme-hook #'set-appropriate-splash)
#+end_src

Doom by default tries to be helpful by showing some commands on the start page, but I no longer find them useful, so I'm going to go for a cleaner aesthetic by removing them and the cursor.
#+begin_src emacs-lisp
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(add-hook! '+doom-dashboard-mode-hook (hide-mode-line-mode 1) (hl-line-mode -1))
(setq-hook! '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src
** Daemon
When I run emacs daemon, I almost always want to have certain features, so it makes sense to preemptively load them, yeah?
#+begin_src emacs-lisp
(defun greedily-do-daemon-setup ()
  (require 'org)
  (when (require 'mu4e nil t)
    (setq! mu4e-confirm-quit t)
    (setq! +mu4e-lock-greedy t)
    (setq! +mu4e-lock-relaxed t)
    (+mu4e-lock-add-watcher)
    (when (+mu4e-lock-available t)
      (mu4e~start)))
  (when (require 'elfeed nil t)
    (run-at-time nil (* 8 60 60) #'elfeed-update)))

(when (daemonp)
  (add-hook 'emacs-startup-hook #'greedily-do-daemon-setup)
  (add-hook! 'server-after-make-frame-hook (switch-to-buffer +doom-dashboard-name)))
#+end_src
** Interaction
This section is entirely about how I interact with emacs, meaning it's going to be a lot of calls to =map!=
**** Evaluate Elisp
The things that makes elisp such a great language is that you can evaluate it as you write. However, the bindings to do this are not ideal for someone who has used vim for years, so I'm changing them.
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("e" . "evaluate")
       :desc "Evaluate elisp in buffer" "b" #'eval-buffer
       :desc "Evaluate defun" "d" #'eval-defun
       :desc "Evaluate elisp expression" "e" #'eval-expression
       :desc "Evaluate last sexpression" "l" #'eval-last-sexp
       :desc "Evaluate elisp in region" "r" #'eval-region))
#+end_src
**** Bookmarks
I'm not sold on the idea of bookmarks yet, and until I better understand them, I'm keeping them separate from the buffer keybinds
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("B" . "bookmark")
        :desc "List bookmarks" "L" #'list-bookmarks
        :desc "Save current bookmarks to bookmark file" "w" #'bookmark-save
        :desc "Set bookmark" "m" #'bookmark-set
        :desc "Delete bookmark" "M" #'bookmark-delete)
      (:prefix ("b" . "buffer")
        :n "m" nil
        :n "M" nil))
#+end_src
**** Registers
Registers are a nice feature that I need to get into the habit of using more. It lets you save arbitrary text to any locations, and then call it back later To make registers easier to use, I make plenty of bindings for them.
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("R" . "registers")
        :desc "Copy to register" "c" #'copy-to-register
        :desc "Frameset to register" "f" #'frameset-to-register
        :desc "Insert contents of register" "i" #'insert-register
        :desc "Jump to register" "j" #'jump-to-register
        :desc "List registers" "l" #'list-registers
        :desc "Number to register" "n" #'number-to-register
        :desc "Interactively choose a register" "r" #'counsel-register
        :desc "View a register" "v" #'view-register
        :desc "Window configuration to register" "w" #'window-configuration-to-register
        :desc "Increment register" "+" #'increment-register
        :desc "Point to register" "SPC" #'point-to-register))
#+end_src
* Doom Setup
So first, a brief explanation of doom's file hierarchy: =init.el= is exclusively for doom modules and their flags; custom configuration can not be placed here. =packages.el= exists solely as a central place where all external packages are specified. The file that most configuration happens in is =config.el=; doom loads on every startup, and it is the rough equivalent of vanilla's =init.el=. =custom.el= is where any variables changed through the =M-x customize= end up. Finally, =cli.el= allows custom cli commands to be added to doom.
** Init.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
As already mentioned, this file only supports doom's predefined modules. Modules are grouped in categories starting with a ~:~, i.e. ~:completion~. If a module has no flags, simply write the module name. If a module has flags, wrap the module and all of it's flags in parens. Each flag will always start with a ~+~.
#+name: init.el
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments none
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src
*** Structure
As you've (hopefully) observed at this point, this is a literate config. I could do this by hand, but one of doom's many great features is it's built in support for it with the =literate= module.
#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparents)
#+end_src
*** Interface
I like to interact with doom in a way somewhere between an IDE and fairly standard vim, so let's make emacs seem like that.
#+name: doom-completion
#+begin_src emacs-lisp
(company           ; the ultimate code completion backend
    +childframe)   ; the ultimate ui for code completion
;;(helm +fuzzy)    ; the *other* search engine for love and life
;;ido              ; the other *other* search engine...
;;(ivy +fuzzy      ; *the* search engine for love and life
;;    +icons       ; wasting clock cycles for nothing
;;    +prescient   ; typing less to remember more
;;    +childframe) ; ivy anywhere you want it
(vertico           ; the searchengine of the future
    +icons)        ; more wasted clock cycles
#+end_src

#+name: doom-ui
#+begin_src emacs-lisp
;;deft             ; notational velocity for Emacs
doom               ; what makes DOOM look the way it does
doom-dashboard     ; a nifty splash screen for Emacs
doom-quit          ; DOOM quit-message prompts when you quit Emacs
(emoji             ; 🙂
 +unicode          ; standards are nice
 +ascii)           ; typing smilies is fun
;;fill-column      ; a `fill-column' indicator
hl-todo            ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
hydra              ; transient state controller
indent-guides      ; highlighted indent columns
minimap            ; show a map of the code on the side
modeline           ; snazzy, Atom-inspired modeline, plus API
nav-flash          ; blink cursor line after big motions
;;neotree          ; a project drawer, like NERDTree for vim
ophints            ; highlight the region an operation acts on
(popup +defaults)  ; tame sudden yet inevitable temporary windows
(ligatures +extra) ; ligatures or substitute text with pretty symbols
;;tabs             ; an tab bar for Emacs
treemacs           ; a project drawer, like neotree but cooler
unicode            ; extended unicode support for various languages
vc-gutter          ; vcs diff in the fringe
vi-tilde-fringe    ; fringe tildes to mark beyond EOB
window-select      ; visually switch windows
workspaces         ; tab emulation, persistence & separate workspaces
zen                ; distraction-free coding or writing
#+end_src

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere) ; come to the dark side, we have cookies
file-templates     ; auto-snippets for empty files
fold               ; (nigh) universal code folding
(format +onsave)   ; automated prettiness
;;god              ; run Emacs commands without modifier keys
;;lispy            ; vim for lisp, for people who don't like vim
multiple-cursors   ; editing in many places at once
;;objed            ; text object editing for the innocent
(parinfer +rust)   ; turn lisp into python, sort of
rotate-text        ; cycle region at point between text candidates
snippets           ; my elves. They type so I don't have to
word-wrap          ; soft wrapping with language-aware indent
#+end_src

#+name: doom-emacs
#+begin_src emacs-lisp
(dired +icons)     ; making dired pretty [functional]
electric           ; smarter, keyword-based electric-indent
(ibuffer +icons)   ; interactive buffer management
(undo +tree)       ; persistent, smarter undo for your inevitable mistakes
vc                 ; version-control and Emacs, sitting in a tree
#+end_src

#+name: doom-term
#+begin_src emacs-lisp
eshell             ; the elisp shell that works everywhere
;;shell            ; simple shell REPL for Emacs
;;term             ; basic terminal emulator for Emacs
vterm              ; the best terminal emulation in Emacs
#+end_src

#+name: doom-checkers
#+begin_src emacs-lisp
(syntax +childframe) ; tasing you for every semicolon you forget
(:if (executable-find "aspell") (spell +aspell +everywhere) ; if we have aspell, use it
(spell +hunspell +everywhere)) ; otherwise, just use hunspell
grammar            ; tasing grammar mistake every you make
#+end_src

#+name: doom-tools
#+begin_src emacs-lisp
;;ansible
(debugger +lsp)    ; FIXME stepping through code, to help you add bugs
direnv
;;docker
editorconfig       ; let someone else argue about tabs vs spaces
;;ein              ; tame Jupyter notebooks with emacs
(eval +overlay)    ; run code, run (also, repls)
gist               ; interacting with github gists
(lookup            ; navigate your code and its documentation
 +dictionary       ; navigate the syntax of the english language
 +docsets)         ; need help remembering what that *one* function does?
(lsp +peek)
(magit +forge)     ; a git porcelain for Emacs
make               ; run make tasks from Emacs
;;pass             ; password manager for nerds
pdf                ; pdf enhancements
;;prodigy          ; FIXME managing external services & code builders
rgb                ; creating color strings
taskrunner         ; taskrunner for all your projects
;;terraform        ; infrastructure as code
;;tmux             ; an API for interacting with tmux
upload             ; map local to remote projects via ssh/ftp
#+end_src

#+name: doom-os
#+begin_src emacs-lisp
;;tty              ; improve the terminal Emacs experience
#+end_src
*** Language Support
One of Doom's core mantras is performance, so all of the language modules are written to not have any effect until a file in that language is opened. As a result, I'm enabling basically every language I ever work with.
#+name: doom-lang
#+begin_src emacs-lisp
;;agda             ; types of types of types of types...
;;beancount        ; count all the money you don't make
(cc +lsp)          ; C/C++/Obj-C madness
;;clojure          ; java with a lisp
;;common-lisp      ; if you've seen one lisp, you've seen them all
;;coq              ; proofs-as-programs
;;crystal          ; ruby at the speed of c
;;csharp           ; unity, .NET, and mono shenanigans
data               ; config/data formats
;;(dart +flutter)  ; paint ui and not much else
;;elixir           ; erlang done right
;;elm              ; care for a cup of TEA?
emacs-lisp         ; drown in parentheses
;;erlang           ; an elegant language for a more civilized age
;;ess              ; emacs speaks statistics
;;faust            ; dsp, but you get to keep your soul
;;fsharp           ; ML stands for Microsoft's Language
;;fstar            ; (dependent) types and (monadic) effects and Z3
;;gdscript         ; the language you waited for
;;(go +lsp)        ; the hipster dialect
(haskell +lsp)     ; a language that's lazier than I am
;;hy               ; readability of scheme w/ speed of python
;;idris            ; a language you can depend on
;;json             ; At least it ain't XML
(java +lsp)        ; the poster child for carpal tunnel syndrome
;;javascript       ; all(hope(abandon(ye(who(enter(here))))))
;;julia            ; a better, faster MATLAB
;;kotlin           ; a better, slicker Java(Script)
(latex +lsp        ; writing papers in Emacs has never been so fun
       +latexmk    ; why would you want to compile only once?
       +cdlatex)   ; math is better when you can type it
;;lean
;;factor
;;ledger           ; an accounting system in Emacs
(lua +lsp          ; one-based indices? one-based indices
     +moonscript)  ; one-based indices in classes
markdown           ; writing docs for people to ignore
;;nim              ; python + lisp at the speed of c
(:if (executable-find "nix") nix); I hereby declare "nix geht mehr!"
;;ocaml            ; an objective camel
(org +pretty       ; organize your plain life in less plain text
     +dragndrop    ; images are a pain to insert
     +noter        ; making english teachers pround with annotations
     +gnuplot      ; we all hate excel
     +present      ; beamer is hard
     +roam2        ; why not have a second brain?
     +pandoc)      ; org already exports enough
;;php              ; perl's insecure younger brother
;;plantuml         ; diagrams for confusing people more
;;purescript       ; javascript, but functional
(python +lsp       ; beautiful is better than ugly
        +pyenv     ; containers have never been more fun
        +conda     ; math for lazy nerds
        +poetry    ; package management is poetic
        +cython)   ; speed is nice
;;qt               ; the 'cutest' gui framework ever
;;racket           ; a DSL for DSLs
;;raku             ; the artist formerly known as perl6
;;rest             ; Emacs as a REST client
;;rst              ; ReST in peace
;;(ruby +rails)    ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
(rust +lsp)        ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala            ; java, but good
;;scheme           ; a fully conniving family of lisps
(sh +lsp)          ; she sells {ba,z,fi}sh shells on the C xor
;;sml              ; need-to-know and you don't need
;;solidity         ; do you need a blockchain? No.
;;swift            ; who asked for emoji variables?
;;terra            ; Earth and Moon in alignment for performance.
;;web              ; the tubes
(yaml +lsp)        ; JSON, but readable
;;zig              ; zag
#+end_src
*** Kitchen Sink in Emacs
If I'm putting all this work into emacs to make it nice, why should I ever leave it.
#+name: doom-email
#+begin_src emacs-lisp
(:if (executable-find "mu") (mu4e +org +gmail))
;;notmuch
;;(wanderlust +gmail)
#+end_src

#+name: doom-app
#+begin_src emacs-lisp
calendar   ; a dated approach to timetabling
emms       ; not as long a name as ncmpcppcpcpcp...
everywhere ; *leave* Emacs!? You must be joking
irc        ; how to become a neckbeard in 1 easy step!
(rss +org) ; news about your news
;;twitter  ; thankfully you don't use this, right? right?
#+end_src
** CLI Tweaks
Of the many things that Henrik is working on right now, CLI is the one that receives the most discussion. Once the CLI overhaul is done, much of this will be either obsolute or drastically different. As such, don't rely on much of this code to work.
#+begin_src emacs-lisp :tangle cli.el :comments none
;;; cli.el -*- lexical-binding: t; -*-
(setq! org-confirm-babel-evaluate nil)

(defun doom-shut-up-a (orig-fn &rest args)
  (quiet! (apply orig-fn args)))

(advice-add 'org-babel-execute-src-block :around #'doom-shut-up-a)
#+end_src
** Async Tangling
Doom adds an =org-mode= hook =+literate-enable-recompile-h=. This is a nice idea, but it’s too blocking for my taste. Since I trust my tangling to be fairly straightforward, I’ll just redefine it to a simpler, async, function.
#+begin_src emacs-lisp
(defadvice! +literate-tangle-async-h ()
  "A very simplified version of `+literate-tangle-h', but async."
  :override #'+literate-tangle-h
  (let ((default-directory doom-private-dir))
    (async-shell-command
     (format "emacs --batch --eval \"(progn \
(require 'org) (setq! org-confirm-babel-evaluate nil) \
(org-babel-tangle-file \\\"%s\\\"))\""
             +literate-config-file))))
#+end_src
* Package Config
This slightly overlaps with the next section, but this block is mostly for packages which are either very atomic and don't belong in the full language config, or apply to multiple languages. Most things that relate to UI are also here.
** Loading Instructions
:PROPERTIES:
:header-args:emacs-lisp: :tangle "packages.el" :comments no
:END:
This file shouldn't be byte compiled, but I don't understand why...
#+begin_src emacs-lisp
;; -*- no-byte-compile: t; -*-
#+end_src
*** Notes/Instructions
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
To install packages in Doom, simply write =(package! /recipe/)=. Most of the time, the recipe is just the package name, but you can also install through git repositories, or local folders. Once the package is defined, it must be installed by running =doom sync= and restarting emacs somehow.
#+begin_warning
Don't disable any packages listed in =~/.config/emacs/core/packages.el=. Doom needs these to have any semblance of functionality.
#+end_warning
**** Published Packages
To install ~some-package~ from these locations, just write:
#+begin_src emacs-lisp
(package! some-package)
#+end_src
**** Packages from git repositories
To install a package directly from a particular repo, you'll need to specify
a ~:recipe~. You'll find documentation on what ~:recipe~ accepts [[https://github.com/raxod502/straight.el#the-recipe-format][here]]:
#+begin_src emacs-lisp
(package! another-package
  :recipe (:host github :repo "username/repo"))
#+end_src

If the package you are trying to install does not contain a ~PACKAGENAME.el~
file, or is located in a subdirectory of the repo, you'll need to specify
~:files~ in the ~:recipe~:
#+begin_src emacs-lisp
(package! this-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))
#+end_src

**** Disabling built-in packages
If you'd like to disable a package included with Doom, for whatever reason,
you can do so here with the ~:disable~ property:
#+begin_src emacs-lisp
(package! builtin-package :disable t)
#+end_src
You can override the recipe of a built in package without having to specify
all the properties for ~:recipe~. These will inherit the rest of its recipe
from Doom or MELPA/ELPA/Emacsmirror:
#+begin_src emacs-lisp
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

Specify a ~:branch~ to install a package from a particular branch or tag.
This is required for some packages whose default branch isn't 'master' (which
our package manager can't deal with; see [[https://github.com/raxod502/straight.el/issues/279][raxod502/straight.el#279]])
#+begin_src emacs-lisp
(package! builtin-package :recipe (:branch "develop"))
#+end_src
*** General Packages
**** UI
***** Command Logging
After messing with my config, or when working with an unfamiliar major-mode, having a log of all the commands being ran is very useful.
#+begin_src emacs-lisp
(package! command-log-mode)
#+end_src
***** Delta
Delta is a great utility that someone made to give =git diff= proper syntax highlighting support. The same person then made an emacs package to let magit use delta.
#+begin_src emacs-lisp
(package! magit-delta :recipe (:host github :repo "dandavison/magit-delta") :pin "1164a6c3e5...")
#+end_src
***** CalcTeX
This extension makes the emacs =calc= mode less terrible.
#+begin_src emacs-lisp
(package! calctex :recipe (:host github :repo "johnbcoughlin/calctex"
                           :files ("*.el" "calctex/*.el" "calctex-contrib/*.el" "org-calctex/*.el" "vendor"))
  :pin "784cf911bc...")
#+end_src
***** Dired
Image previews are great
#+begin_src emacs-lisp
(package! peep-dired)
#+end_src
***** Info Colors
The man pages in emacs are great, but let's make them look better with pitch fontification.
#+begin_src emacs-lisp
(package! info-colors :pin "47ee73cc19b1049eef32c9f3e264ea7ef2aaf8a5")
#+end_src
***** Tree-sitter
Tree-sitter is an editor agnostic protocol to help editors "understand" code, and then highlight them accordingly
#+begin_src emacs-lisp
(package! tree-sitter)
(package! tree-sitter-langs)
#+end_src

Now let's just make sure we're using it
#+begin_src emacs-lisp :tangle yes
(use-package! tree-sitter
  :config
  (require 'tree-sitter-langs)
  (global-tree-sitter-mode)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))
#+end_src
***** Screenshots
Let's make it as easy as we can to take nice screenshots
#+begin_src emacs-lisp
(package! screenshot :recipe (:local-repo "lisp/screenshot"))
#+end_src

Now we just need to get the links to our screenshots, so let's use this script [[github:calinou/0x0][here]], which I've named upload on my system
#+begin_src emacs-lisp
(use-package! screenshot
  :defer t
  :config (setq! screenshot-upload-fn "upload %s 2>/dev/null"))
#+end_src
***** Window Management
Tmux inspired layout rotation.
#+begin_src emacs-lisp
(package! rotate :pin "4e9ac3ff80...")
#+end_src

**** Functionality
***** Emacs Everywhere
This should be obvious
#+begin_src emacs-lisp
(package! emacs-everywhere :recipe (:local-repo "lisp/emacs-everywhere") :pin nil)
#+end_src
***** Large Files
When you open files in emacs, it has to load the entire thing into RAM, and then have the modes process all of it. This becomes very slow when the files are larger, so someone created a plugin to load files in chunks.
#+begin_src emacs-lisp
(package! vlf :recipe (:host github :repo "m00natic/vlfi" :files ("*.el"))
  :pin "cc02f25337...")
#+end_src

Now, let's just load the plugin in the time we're not doing anything to keep performance.
#+begin_src emacs-lisp :tangle yes
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src
***** Definitions
Doom has the function =define-word=, but I want this to work when I can't always get online. Hence, =sdcv= and the =lexic= package.
#+begin_src emacs-lisp
(package! lexic :recipe
  (:host github :repo "tecosaur/lexic"))
#+end_src
***** Word Count
Occasionally, I am required to write something that meets a certain word requirement, so this is nice.
#+begin_src emacs-lisp
(package! wc-mode)
#+end_src
***** Project Management
Starting a new project can be a pain, so let's set up some template systems to automate it. I've chose to use =ptemplate= in this case, and Henrik said that this might become an official package, so this might not be needed in the future.
#+begin_src emacs-lisp
(package! ptemplate :recipe (:host github :repo "nbfalcon/ptemplate"))
#+end_src

ptemplate also has a dedicated template repo. While it only has 4 templates, and they're never ones that will get used, they d work as a learning resource, so...
#+begin_src emacs-lisp
(package! ptemplate-templates :recipe (:host github :repo "nbfalcon/ptemplate-templates"))
#+end_src
***** XKCD
Even though xkcd mostly exists as satire, it's actually pretty helpful to explain things in documents like this, so why not automate the insertion of arbitrary xkcd comics?
#+begin_src emacs-lisp
(package! xkcd)
#+end_src

**** Fun/Useless
Every so often, you want everyone else to know that you’re typing, or just to amuse oneself. Introducing: typewriter sounds!
#+begin_src emacs-lisp
(package! selectric-mode :pin "1840de71f7...")
#+end_src

Why not flash words on the screen. Why not — hey, it could be fun.
#+begin_src emacs-lisp
(package! spray :pin "74d9dcfa2e...")
#+end_src

With all our fancy Emacs themes, my terminal is missing out!
#+begin_src emacs-lisp
(package! theme-magic :pin "844c4311bd...")
#+end_src

What’s even the point of using Emacs unless you’re constantly telling everyone about it?
#+begin_src emacs-lisp
(package! elcord :pin "25531186c1...")
#+end_src

For some reason, I find myself demoing Emacs every now and then. Showing what keyboard stuff I’m doing on-screen seems helpful. While screenkey does exist, having something that doesn't cover up screen content is nice.
#+begin_src emacs-lisp
(package! keycast :pin "a3a0798349...")
#+end_src

Now lets just load this lazily.
#+begin_src emacs-lisp :tangle yes
(use-package! keycast
  :commands keycast-mode
  :config
  (define-minor-mode keycast-mode
    "Show current command and its key binding in the mode line."
    :global t
    (if keycast-mode
        (progn
          (add-hook 'pre-command-hook 'keycast--update t)
          (add-to-list 'global-mode-string '("" mode-line-keycast " ")))
      (remove-hook 'pre-command-hook 'keycast--update)
      (setq! global-mode-string (remove '("" mode-line-keycast " ") global-mode-string))))
  (custom-set-faces!
    '(keycast-command :inherit doom-modeline-debug
                      :height 0.9)
    '(keycast-key :inherit custom-modified
                  :height 1.1
                  :weight bold)))
#+end_src

In a similar manner, gif-screencast may come in handy.
#+begin_src emacs-lisp
(package! gif-screencast :pin "1145e676b1...")
#+end_src
We can lazy load this using the start/stop commands.
There's some issues here though, so let's see if we can magic it together
TODO Improve =gif-screencast= documentation
#+begin_src emacs-lisp :tangle yes
(use-package! gif-screencast
  :commands gif-screencast-mode
  :config
  (map! :map gif-screencast-mode-map
        :g "<f8>" #'gif-screencast-toggle-pause
        :g "<f9>" #'gif-screencast-stop)
  (setq! gif-screencast-program "maim"
        gif-screencast-args `("--quality" "3" "-i" ,(string-trim-right
                                                     (shell-command-to-string
                                                      "xdotool getactivewindow")))
        gif-screencast-optimize-args '("--batch" "--optimize=3" "--usecolormap=/tmp/doom-color-theme"))
  (defun gif-screencast-write-colormap ()
    (f-write-text
     (replace-regexp-in-string
      "\n+" "\n"
      (mapconcat (lambda (c) (if (listp (cdr c))
                                 (cadr c))) doom-themes--colors "\n"))
     'utf-8
     "/tmp/doom-color-theme" ))
  (gif-screencast-write-colormap)
  (add-hook 'doom-load-theme-hook #'gif-screencast-write-colormap))
#+end_src
*** Language Packages
**** \LaTeX
LaTeX snippets are much better if they automatically expand, because I can then type what I /want/ displayed, and the snippet engine will automatically expand it into the correct syntax. Yasnippet howeever, is very bad at automatic expansion, so I'm using aas for this purpose, along with Teco's aas snippets
#+begin_src emacs-lisp
(package! aas :recipe (:host github :repo "ymarco/auto-activating-snippets")
  :pin "3076cefea0f6ae9d7757f13c27b5602e007b58ec")
(package! laas :recipe
  (:host github :repo "tecosaur/LaTeX-auto-activating-snippets"))
#+end_src
And some basic config
#+begin_src emacs-lisp :tangle yes
(use-package! aas
  :commands aas-mode)

(use-package! laas
  :hook (LaTeX-mode . laas-mode)
  :config
  (defun laas-tex-fold-maybe ()
    (unless (equal "/" aas-transient-snippet-key)
      (+latex-fold-last-macro-a)))
  (add-hook 'aas-post-snippet-expand-hook #'laas-tex-fold-maybe))
#+end_src

I don't trust AucTeX very much at all, but I trust this commit slightly more...
#+begin_src emacs-lisp
(package! auctex :pin "6440ec5964dcbe58155e28f00f84ec0118d8fb7b")
#+end_src
**** SystemD
Well, I'm running Artix now, so this is effectively useless, but I haven't converted the services in this file to s6 yet, so I'm keeping it around.
#+begin_src emacs-lisp
(package! systemd)
#+end_src
**** Org
***** Improve agenda/capture
The agenda is nice, but a souped up version is nicer.
#+begin_src emacs-lisp
(package! org-super-agenda :pin "f5e80e4d0da6b2eeda9ba21e021838fa6a495376")
#+end_src

Similarly ~doct~ (Declarative Org Capture Templates) seems to be a nicer way to
set up org-capture.
#+begin_src emacs-lisp
(package! doct
  :recipe (:host github :repo "progfolio/doct")
  :pin "67fc46c8a68989b932bce879fbaa62c6a2456a1f")
#+end_src
***** Visuals
Org tables aren't the prettiest thing to look at. This package is supposed to
redraw them in the buffer with box-drawing characters. Sounds like an
improvement to me! We'll make use of this with =writeroom-mode=.
#+begin_src emacs-lisp
(package! org-pretty-table
  :recipe (:host github :repo "Fuco1/org-pretty-table") :pin "87772a9469d91770f87bfa788580fca69b9e697a")
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! org-pretty-table
  :commands (org-pretty-table-mode global-org-pretty-table-mode))
#+end_src

For automatically toggling LaTeX fragment previews as the cursor moves in and
out of them there's this nice package
#+begin_src emacs-lisp
(package! org-fragtog :pin "0151cabc7aa9f244f82e682b87713b344d780c23")
#+end_src

Then for showing org formatting markers (=*/=~=)  when inside such a region, we
have =org-appear=.
#+begin_src emacs-lisp
(package! org-appear :recipe (:host github :repo "awth13/org-appear")
  :pin "6ee49875f8bdefafbde849f5628d673e9740cf8c")
#+end_src

~org-superstar-mode~ is great. While we're at it we may as well make tags prettier as well
#+begin_src emacs-lisp
(package! org-pretty-tags :pin "5c7521651b35ae9a7d3add4a66ae8cc176ae1c76")
#+end_src

This is great for managing tables of content, and it makes ~indirect buffers~ mostly obsolete.
#+begin_src emacs-lisp
(package! org-ol-tree :recipe (:host github :repo "Townk/org-ol-tree")
  :pin "207c748aa5fea8626be619e8c55bdb1c16118c25")
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! org-ol-tree
  :commands org-ol-tree)
(map! :map org-mode-map
      :after org
      :localleader
      :desc "Outline" "O" #'org-ol-tree)
#+end_src

There's this nice package that can provide nice syntax highlighting with LaTeX
exports.
#+begin_src emacs-lisp
(package! engrave-faces :recipe (:local-repo "lisp/engrave-faces"))
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! engrave-faces-latex
  :after ox-latex)
#+end_src
***** Functionality
Thanks to the /wonderful/ variety in markdown implementations and specifications, there is no standard for most elements. ~org-md~'s solution to this is just to use HTML for anything that is non-standard. However, this is clearly not ideal, so people created ~ox-gfm~ to support github's implemation.
#+begin_src emacs-lisp
(package! ox-gfm)
#+end_src

#+begin_src emacs-lisp
(use-package! ox-gfm
  :after org)
#+end_src

There's a really cool package in development (in other words, mostly broken) to /transclude/ Org document content.
#+begin_src emacs-lisp
(package! org-transclusion :recipe (:host github :repo "nobiot/org-transclusion")
  :pin "daa18df6de26b74badab0372e8a64fbde6a7be71")
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! org-transclusion
  :commands org-transclusion-mode
  :init
  (map! :after org :map org-mode-map
        "<f12>" #'org-transclusion-mode))
#+end_src

Came across this and ... it's cool
#+begin_src emacs-lisp
(package! org-graph-view :recipe (:host github :repo "alphapapa/org-graph-view") :pin "13314338d70d2c19511efccc491bed3ca0758170")
#+end_src

Sometimes I'm given non-org files, that's very sad. Luckily Pandoc offers a way
to make that right again, and this package makes that even easier to do.
#+begin_src emacs-lisp
(package! org-pandoc-import :recipe
  (:local-repo "lisp/org-pandoc-import" :files ("*.el" "filters" "preprocessors")))
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! org-pandoc-import
  :after org)
#+end_src

I've started using Org-roam, and it's nice, but there are many extra packages to integrate with it.
#+begin_src emacs-lisp
(package! websocket)
(package! org-roam-ui :recipe (:host github :repo "org-roam/org-roam-ui" :files ("*.el" "out")))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! websocket
    :after org-roam)

(use-package! org-roam-ui
    :after org-roam ;; or :after org
;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
;;         a hookable mode anymore, you're advised to pick something yourself
;;         if you don't care about startup time, use
;;  :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src
**** Graphviz
Making diagrams easier so everyone can be confused faster...
#+begin_src emacs-lisp
(package! graphviz-dot-mode)
#+end_src
**** VimL
Well, to quote our lord Henrik, even brainfuck is easier to write than VimL, so let's make it /marginally/ easier.
#+begin_src emacs-lisp
(package! vimrc-mode)
#+end_src
** Abbrev Mode
Abbreviations are really useful. They are slightly less useful when using =yasnippet=, but that's besides the point. However, =abbrev-mode= assume you want a separate abbrev list for every major mode, and I don't.
#+begin_src emacs-lisp
(add-hook 'doom-first-buffer-hook
          (defun +abbrev-file-name ()
                (setq-default abbrev-mode t)
                (setq! abbrev-file-name (expand-file-name "abbrev.el" doom-private-dir))))
#+end_src
** Calc
*** Defaults
First off, let's make the calculator more like a dedicated calculator with radians and true-value expressions.
#+begin_src emacs-lisp
(setq calc-angle-mode 'rad  ; radians are rad
      calc-symbolic-mode t) ; keeps expressions like \sqrt{2} irrational for as long as possible
#+end_src
*** CalcTeX
CalcTex makes the calculator more WYSIWYG, instead of the weird combination of reverse-polish notation, function calls, and LaTeX. For some reason, the dev of the package thought it would be a good idea to vendor the LaTeX packages used, so let's fix it.
#+begin_src emacs-lisp
(use-package! calctex
  :commands calctex-mode
  :init
  (add-hook 'calc-mode-hook #'calctex-mode)
  :config
  (setq calctex-additional-latex-packages "
\\usepackage[usenames]{xcolor}
\\usepackage{soul}
\\usepackage{adjustbox}
\\usepackage{amsmath}
\\usepackage{amssymb}
\\usepackage{siunitx}
\\usepackage{cancel}
\\usepackage{mathtools}
\\usepackage{mathalpha}
\\usepackage{xparse}
\\usepackage{arevmath}"
        calctex-additional-latex-macros
        (concat calctex-additional-latex-macros
                "\n\\let\\evalto\\Rightarrow"))
  (defadvice! no-messaging-a (orig-fn &rest args)
    :around #'calctex-default-dispatching-render-process
    (let ((inhibit-message t) message-log-max)
      (apply orig-fn args)))
  ;; Fix hardcoded dvichop path (whyyyyyyy)
  (let ((vendor-folder (concat (file-truename doom-local-dir)
                               "straight/"
                               (format "build-%s" emacs-version)
                               "/calctex/vendor/")))
    (setq calctex-dvichop-sty (concat vendor-folder "texd/dvichop")
          calctex-dvichop-bin (concat vendor-folder "texd/dvichop")))
  (unless (file-exists-p calctex-dvichop-bin)
    (message "CalcTeX: Building dvichop binary")
    (let ((default-directory (file-name-directory calctex-dvichop-bin)))
      (call-process "make" nil nil nil))))
#+end_src
*** Embedded Calc
Finally, it is possible to use calc on LaTeX expressions in the document, with the downside that the keybinding is janky.
#+begin_src emacs-lisp
(map! :map calc-mode-map
      :after calc
      :localleader
      :desc "Embedded calc (toggle)" "e" #'calc-embedded)
(map! :map org-mode-map
      :after org
      :localleader
      :desc "Embedded calc (toggle)" "E" #'calc-embedded)
(map! :map latex-mode-map
      :after latex
      :localleader
      :desc "Embedded calc (toggle)" "e" #'calc-embedded)
#+end_src
** Centaur Tabs
Sometimes the tab bar /really/ bothers me, so it's nice to be able to quickly disable it. Oh, and some of the characters the tab bar use cause lag.
#+begin_src emacs-lisp
(after! centaur-tabs
  (centaur-tabs-mode -1)
  (setq! centaur-tabs-height 24
        centaur-tabs-set-icons t
        centaur-tabs-modified-marker "o"
        centaur-tabs-close-button "×"
        centaur-tabs-set-bar 'over
        centaur-tabs-gray-out-icons 'buffer
        centaur-tabs-style "slant"))
(map! :leader
      :desc "Toggle tab locally" "t C" #'centaur-tabs-local-mode
      :desc "Toggle tabs on/off" "t c" #'centaur-tabs-mode)
#+end_src
** Company
Completion all the time, yeah?
#+begin_src emacs-lisp
(after! company
        (setq company-idle-delay 0.5
              company-minimum-prefix-length 2
              company-show-numbers t))
(setq! history-length 1000
       yas-triggers-in-field)
#+end_src
** Plain Text
=ispell= is nice, so let's have it on in all of the text modes, viz., =text=, =markdown=, and =gfm=.
#+begin_src emacs-lisp
(set-company-backend!
  '(text-mode
    markdown-mode
    gfm-mode)
  '(:seperate
    company-ispell
    company-files
    company-yasnippet))
#+end_src
** Eros Eval
Why not make this slightly better looking while we're at it?
#+begin_src emacs-lisp
(setq eros-eval-result-prefix "⟹ ")
#+end_src
** Emacs everywhere
** Evil
There's a mode called =evil-escape-mode=, which lets you leave insert mode by typing =jk= fairly fast. However, I absolutely hate this functionality, so I'm removing it.
#+begin_src emacs-lisp :tangle packages.el
(package! evil-escape :disable t)
#+end_src
For some reason, having this one evil extension causes me to randomly get an error =Device 1 is not a termcap terminal device=, so let's disable it.
#+begin_src emacs-lisp :tangle packages.el
(package! evil-terminal-cursor-changer :disable t)
#+end_src
When I make a substitution, it's usually global, so let's save some keystrokes.
#+begin_src emacs-lisp
(after! evil (setq evil-ex-substitute-global t))
#+end_src
** Info
#+begin_src emacs-lisp
(use-package! info-colors
  :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)

(add-hook 'Info-mode-hook #'mixed-pitch-mode)
#+end_src
** Magit
Magit is really nice by default, but the diffs don't get any syntax-highlighting by default. This can be changed by using [[github:dandavison/magit-delta][magit-delta]].
#+begin_src emacs-lisp
(after! magit
   (magit-delta-mode +1))
#+end_src

I use [[https://github.com/TheLocehiliosan/yadm][yadm]] to manage my dotfiles, and I want to be able to use this in emacs, so...
#+begin_src emacs-lisp
(require 'tramp)
(add-to-list 'tramp-methods
 '("yadm"
   (tramp-login-program "yadm")
   (tramp-login-args (("enter")))
   (tramp-login-env (("SHELL") ("/bin/sh")))
   (tramp-remote-shell "/bin/sh")
   (tramp-remote-shell-args ("-c"))))
#+end_src
** Which-key
Let's make this appear much faster
#+begin_src emacs-lisp
(setq which-key-idle-delay 0.5)
#+end_src

Does =evil-= need to appear on every binding? No.
#+begin_src emacs-lisp
(setq which-key-allow-multiple-replacements t)
(after! which-key
  (pushnew!
   which-key-replacement-alist
   '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "◂\\1"))
   '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "◃\\1"))
   ))
#+end_src

** Ispell
#+begin_src emacs-lisp
(setq ispell-dictionary "en-custom")
#+end_src
I want to keep track of all of the words I'm putting in my personal dictionary, so let's store it in =$DOOMDIR=
#+begin_src emacs-lisp
(setq ispell-personal-dictionary (expand-file-name ".ispell_personal" doom-private-dir))
#+end_src
** LSP
Because Doom focuses so much on performance, some nice UI features from lsp are disabled.
#+begin_src emacs-lisp
(defun doom/lsp-mode-setup ()
  (setq! lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols)
         lsp-ui-sideline-show-hover t)
  (lsp-ui-mode 1)
  (lsp-headerline-breadcrumb-mode 1)
  (lsp-ui-peek-enable 1))

(use-package! lsp-mode
  :hook (lsp-mode . doom/lsp-mode-setup))
#+end_src
*** LSP Servers
Some languages and servers are not default on doom, even though they are the ones that function best. This section goes through and changes these defaults
#+begin_src emacs-lisp
(after! rustic
  (setq rustic-lsp-server 'rls))
(after! ccls
  (setq ccls-initialization-options '(:index (:comments 2) :completion (:detailedLabel t)))
  (set-lsp-priority! 'ccls 2))
#+end_src

** Yasnippets
This makes it possible to make "dynamic" snippets where e-lisp functions are called on snippet expansion
#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src
** Smart Parenthesis
When I use org, I have to use the << >> pairing a lot, so let's make it a valid combination for smart parenthesis
#+begin_src emacs-lisp
(sp-local-pair
  '(org-mode)
   "<<" ">>"
   :actions '(insert))
#+end_src
** Ptemplate
#+begin_src emacs-lisp
(setq! ptemplate-project-template-dirs '("~/Documents/code/skeletons" "~/.config/emacs/.local/straight/build-28.0.50/ptemplate-templates/rsc/project-templates"))
(use-package ptemplate-templates
  :after (ptemplate)
  :config (ptemplate-templates-mode 1))
#+end_src
** Mixed Pitch
#+begin_src emacs-lisp
(autoload #'mixed-pitch-serif-mode "mixed-pitch"
  "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch." t)

(after! mixed-pitch
  (defface variable-pitch-serif
    '((t (:family "serif")))
    "A variable-pitch face with serifs."
    :group 'basic-faces)
  (setq mixed-pitch-set-height t)
  (setq variable-pitch-serif-font (font-spec :family "Alegreya" :size 14))
  (set-face-attribute 'variable-pitch-serif nil :font variable-pitch-serif-font)
  (defun mixed-pitch-serif-mode (&optional arg)
    "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch."
    (interactive)
    (let ((mixed-pitch-face 'variable-pitch-serif))
      (mixed-pitch-mode (or arg 'toggle)))))
#+end_src
As mixed pitch uses the variable mixed-pitch-face, we can create a new function to apply mixed pitch with a serif face instead of the default. This was created for writeroom mode.

However, we are still missing some alpabetic ligatures, so let's add them.
#+begin_src emacs-lisp
(set-char-table-range composition-function-table ?f '(["\\(?:ff?[fijlt]\\)" 0 font-shape-gstring]))
(set-char-table-range composition-function-table ?T '(["\\(?:Th\\)" 0 font-shape-gstring]))
#+end_src
** Projectile mode
#+begin_src emacs-lisp
(setq projectile-project-search-path '("~/Documents/code/" "~/.config/"))
#+end_src

Looking at documentation via SPC h f and SPC h v and looking at the source can add package source directories to projectile. This isn't desirable in my opinion.
#+begin_src emacs-lisp
(setq projectile-ignored-projects '("~/" "/tmp" "~/.emacs.d/.local/straight/repos/"))
(defun projectile-ignored-project-function (filepath)
  "Return t if FILEPATH is within any of `projectile-ignored-projects'"
  (or (mapcar (lambda (p) (s-starts-with-p p filepath)) projectile-ignored-projects)))
#+end_src

** Zen
Doom zooms in too much
#+begin_src emacs-lisp
(setq +zen-text-scale 0.8)
#+end_src

When zen is on in org, keep org nice, thank you!
#+begin_src emacs-lisp
(defvar +zen-serif-p nil
  "Whether to use a serifed font with `mixed-pitch-mode'.")
(after! writeroom-mode
  (defvar-local +zen--original-org-indent-mode-p nil)
  (defvar-local +zen--original-mixed-pitch-mode-p nil)
  (defvar-local +zen--original-solaire-mode-p nil)
  (defvar-local +zen--original-org-pretty-table-mode-p t)
  (defun +zen-enable-mixed-pitch-mode-h ()
    "Enable `mixed-pitch-mode' when in `+zen-mixed-pitch-modes'."
    (when (apply #'derived-mode-p +zen-mixed-pitch-modes)
      (if writeroom-mode
          (progn
            (setq +zen--original-solaire-mode-p solaire-mode)
            (solaire-mode -1)
            (setq +zen--original-mixed-pitch-mode-p mixed-pitch-mode)
            (funcall (if +zen-serif-p #'mixed-pitch-serif-mode #'mixed-pitch-mode) 1))
        (funcall #'mixed-pitch-mode (if +zen--original-mixed-pitch-mode-p 1 -1))
        (when +zen--original-solaire-mode-p (solaire-mode 1)))))
  (pushnew! writeroom--local-variables
            'display-line-numbers
            'visual-fill-column-width
            'org-adapt-indentation
            'org-superstar-headline-bullets-list
            'org-superstar-remove-leading-stars)
  (add-hook 'writeroom-mode-enable-hook
            (defun +zen-prose-org-h ()
              "Reformat the current Org buffer appearance for prose."
              (when (eq major-mode 'org-mode)
                (setq display-line-numbers nil
                      visual-fill-column-width 60
                      org-adapt-indentation nil)
                (when (featurep 'org-superstar)
                  (setq-local org-superstar-headline-bullets-list '("🙘" "🙙" "🙚" "🙛")
                              ;; org-superstar-headline-bullets-list '("🙐" "🙑" "🙒" "🙓" "🙔" "🙕" "🙖" "🙗")
                              org-superstar-remove-leading-stars t)
                  (org-superstar-restart))
                (setq
                 +zen--original-org-indent-mode-p org-indent-mode
                 +zen--original-org-pretty-table-mode-p (bound-and-true-p org-pretty-table-mode))
                (org-indent-mode -1)
                (org-pretty-table-mode 1))))
  (add-hook 'writeroom-mode-disable-hook
            (defun +zen-nonprose-org-h ()
              "Reverse the effect of `+zen-prose-org'."
              (when (eq major-mode 'org-mode)
                (when (featurep 'org-superstar)
                  (org-superstar-restart))
                (when +zen--original-org-indent-mode-p (org-indent-mode 1))
                ;; (unless +zen--original-org-pretty-table-mode-p (org-pretty-table-mode -1))
                ))))
#+end_src
* TODO Language Config
This is all about tweaking language specific packages or functionality to make these coding languages less miserable to use.
** File Types
#+begin_src emacs-lisp
(set-file-template! "\\.tex$" :trigger "__" :mode 'latex-mode)
(set-file-template! "/LICEN[CS]E$" :trigger '+file-templates/insert-license)
#+end_src
** Plain Text
#+begin_src emacs-lisp
(after! text-mode
  (add-hook! 'text-mode-hook
             ;; Apply ANSI color codes
             (with-silent-modifications
               (ansi-color-apply-on-region (point-min) (point-max)))))
#+end_src

** TODO Org
:PROPERTIES:
:CUSTOM_ID: org
:header-args:emacs-lisp: :tangle no :noweb-ref org-config
:END:
Org mode is the main reason I use emacs. At it's core, Org mode is a markup language similar to markdown. However, it contains many other features that make it much more useful. This sectino is primarily about setting up all of those extra features. Sadly, doing this much config will lag emacs dramatically, so it's necessary to wrap it in a =after!=  block.
#+begin_src emacs-lisp :noweb no-export :tangle yes :noweb-ref nil
(after! org
 <<org-config>>)
#+end_src

*** Behavior
**** Defaults
#+begin_src emacs-lisp
(setq org-directory "~/org"                      ; let's put files here
      org-use-property-inheritance t              ; it's convenient to have properties inherited
      org-log-done 'time                          ; having the time a item is done sounds convenient
      org-log-done 'note                          ; being able to write about what you've done is nice
      org-list-allow-alphabetical t               ; have a. A. a) A) list bullets
      org-export-in-background t                  ; run export processes in external emacs process
      org-catch-invisible-edits 'smart            ; try not to accidently do weird stuff in invisible regions
      org-export-with-sub-superscripts '{})       ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}
#+end_src

The =:comments:= header-argument is really useful, so let's make it the standard.
#+begin_src emacs-lisp
(setq org-babel-default-header-args
      '((:session . "none")
        (:results . "replace")
        (:exports . "code")
        (:cache . "no")
        (:noweb . "no")
        (:hlines . "no")
        (:tangle . "no")
        (:comments . "link")))
#+end_src

For some reason, someone thought it would be a good idea to turn ~visual-line-mode~ =on=, and ~auto-fill-mode~ =off=, even though this breaks most of the great features of org mode and \LaTeX, so we'll just turn it off, and switch it back on for less important modes.
#+begin_src emacs-lisp
(remove-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'tex-mode-hook #'auto-fill-mode)
#+end_src

On /very/ rare occasions, I find that I don't want to use the =hjkl= keys, and instead want arrows, so let's add it.
#+begin_src emacs-lisp
(map! :map evil-org-mode-map
      :after evil-org
      :n "g <up>" #'org-backward-heading-same-level
      :n "g <down>" #'org-forward-heading-same-level
      :n "g <left>" #'org-up-element
      :n "g <right>" #'org-down-element)
#+end_src

Right now, some of the basic ~evil-org~ keys are shadowed, making it hard to move. There is a pull open on doom to fix this, but it hasn't merged yet, so I'll just do it the lazy way
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'evil-org-mode)
(map! :map evil-org-mode-map
      :after evil-org
      :n "g k" #'org-backward-heading-same-level
      :n "g j" #'org-forward-heading-same-level
      :n "g h" #'org-up-element
      :n "g l" #'org-down-element)
#+end_src
**** Extra Functionality
***** Buffer Creation
Org is great and all, but it can occasionally be a pain to make an org buffer, so let's change that.
#+begin_src emacs-lisp
(evil-define-command evil-buffer-org-new (count file)
  "Creates a new ORG buffer replacing the current window, optionally
   editing a certain FILE"
  :repeat nil
  (interactive "P<f>")
  (if file
      (evil-edit file)
    (let ((buffer (generate-new-buffer "*new org*")))
      (set-window-buffer nil buffer)
      (with-current-buffer buffer
        (org-mode)))))
(map! :leader
      (:prefix "b"
       :desc "New empty ORG buffer" "o" #'evil-buffer-org-new))
#+end_src
***** Bullets
In most word processors, if you add depth to a list, the listing bullets will change in some way. Org, however, does not do this by default.
#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+") ("*" . "+") ("1." . "a.")))
#+end_src
***** CdLaTeX
=cdlatex= is a package that is supposed to make inserting environment keys for Latex easier.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+end_src
The environment insert key =C-c }= is nice, but its also nice to edit those environments afterwards.
#+begin_src emacs-lisp
(defadvice! org-edit-latex-emv-after-insert ()
  :after #'org-cdlatex-environment-indent
  (org-edit-latex-environment))
#+end_src
***** Flycheck
It's nice to be showed the mistakes you made in your prose.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-flyspell)
#+end_src
***** View Exported Files
In \LaTeX, there is a keybinding ='localeader v= that shows the file you exported. It would be really nice if we had this same functionality in org.
#+begin_src emacs-lisp
(map! :map org-mode-map
      :localleader
      :desc "View exported file" "v" #'org-view-output-file)

(defun org-view-output-file (&optional org-file-path)
  "Visit buffer open on the first output file (if any) found, using `org-view-output-file-extensions'"
  (interactive)
  (let* ((org-file-path (or org-file-path (buffer-file-name) ""))
         (dir (file-name-directory org-file-path))
         (basename (file-name-base org-file-path))
         (output-file nil))
    (dolist (ext org-view-output-file-extensions)
      (unless output-file
        (when (file-exists-p
               (concat dir basename "." ext))
          (setq output-file (concat dir basename "." ext)))))
    (if output-file
        (if (member (file-name-extension output-file) org-view-external-file-extensions)
            (browse-url-xdg-open output-file)
          (pop-to-buffer (or (find-buffer-visiting output-file)
                             (find-file-noselect output-file))))
      (message "No exported file found"))))

(defvar org-view-output-file-extensions '("pdf" "md" "rst" "txt" "tex" "html")
  "Search for output files with these extensions, in order, viewing the first that matches")
(defvar org-view-external-file-extensions '("html")
  "File formats that should be opened externally.")
#+end_src
**** Snippet Helpers
I love the =src-blocks= of org-mode, but the headers can be a pain to:
+ Type them out
+ remember what values are valid
+ repeatedly specify languages
We can solve these problems in just a few steps:
+ Have one-letter snips, based on =(point)= being inside a src header
+ creating a nice prompt to show valid values
+ pre-filling the =src-block= language with whatever we used last
For header args, I use the following abbreviations:
+ =r= for =:results=
+ =e= for =:exports=
+ =v= for =:eval=
+ =s= for =:session=
+ =d= for =:dir=
#+begin_src emacs-lisp
(defun +yas/org-src-header-p ()
  "Determine whether `point' is within a src-block header or header-args."
  (pcase (org-element-type (org-element-context))
    ('src-block (< (point) ; before code part of the src-block
                   (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                   (forward-line 1)
                                   (point))))
    ('inline-src-block (< (point) ; before code part of the inline-src-block
                          (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                          (search-forward "]{")
                                          (point))))
    ('keyword (string-match-p "^header-args" (org-element-property :value (org-element-context))))))
#+end_src
Now we just need a function that can reference the snippets to give us options.
#+begin_src emacs-lisp
(defun +yas/org-prompt-header-arg (arg question values)
  "Prompt the user to set ARG header property to one of VALUES with QUESTION.
The default value is identified and indicated. If either default is selected,
or no selection is made: nil is returned."
  (let* ((src-block-p (not (looking-back "^#\\+property:[ \t]+header-args:.*" (line-beginning-position))))
         (default
           (or
            (cdr (assoc arg
                        (if src-block-p
                            (nth 2 (org-babel-get-src-block-info t))
                          (org-babel-merge-params
                           org-babel-default-header-args
                           (let ((lang-headers
                                  (intern (concat "org-babel-default-header-args:"
                                                  (+yas/org-src-lang)))))
                             (when (boundp lang-headers) (eval lang-headers t)))))))
            ""))
         default-value)
    (setq values (mapcar
                  (lambda (value)
                    (if (string-match-p (regexp-quote value) default)
                        (setq default-value
                              (concat value " "
                                      (propertize "(default)" 'face 'font-lock-doc-face)))
                      value))
                  values))
    (let ((selection (ivy-read question values :preselect default-value)))
      (unless (or (string-match-p "(default)$" selection)
                  (string= "" selection))
        selection))))
#+end_src
Oh, and we need to get the language for our =src-blocks=. As we already have to fetch info, we might as well do things like determine the most common language to use for things that have no =header-args= set (using =#+properties=).
#+begin_src emacs-lisp
(defun +yas/org-src-lang ()
  "Try to find the current language of the src/header at `point'.
Return nil otherwise."
  (let ((context (org-element-context)))
    (pcase (org-element-type context)
      ('src-block (org-element-property :language context))
      ('inline-src-block (org-element-property :language context))
      ('keyword (when (string-match "^header-args:\\([^ ]+\\)" (org-element-property :value context))
                  (match-string 1 (org-element-property :value context)))))))

(defun +yas/org-last-src-lang ()
  "Return the language of the last src-block, if it exists."
  (save-excursion
    (beginning-of-line)
    (when (re-search-backward "^[ \t]*#\\+begin_src" nil t)
      (org-element-property :language (org-element-context)))))

(defun +yas/org-most-common-no-property-lang ()
  "Find the lang with the most source blocks that has no global header-args, else nil."
  (let (src-langs header-langs)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+begin_src" nil t)
        (push (+yas/org-src-lang) src-langs))
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+property: +header-args" nil t)
        (push (+yas/org-src-lang) header-langs)))

    (setq src-langs
          (mapcar #'car
                  ;; sort alist by frequency (desc.)
                  (sort
                   ;; generate alist with form (value . frequency)
                   (cl-loop for (n . m) in (seq-group-by #'identity src-langs)
                            collect (cons n (length m)))
                   (lambda (a b) (> (cdr a) (cdr b))))))

    (car (cl-set-difference src-langs header-langs :test #'string=))))
#+end_src
**** Convert Old To New
Everyone used to use the =#+CAPITAL= Keywords. Later, people realized that the =#+lowercase= keywords are easier, and nicer to look at. As a result, the old capital version are only used in the manual.
#+begin_quote
Org is standardized on lower case. Uppercase is used in the manual as a poor
man's bold, and supported for historical reasons. --- [[https://orgmode.org/list/87tuuw3n15.fsf@nicolasgoaziou.fr][Nicolas Goaziou on the Org ML]]
#+end_quote
It kinda a pain to convert old documents to use the lowercase versions, so why not make a transcoding-type function to do it for us? Its not perfect, and will miss occasional edge cases, but it should work.
#+begin_src emacs-lisp
(defun org-syntax-convert-keyword-case-to-lower ()
  "Convert all #+KEYWORDS to #+keywords."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((count 0)
          (case-fold-search nil))
      (while (re-search-forward "^[ \t]*#\\+[A-Z_]+" nil t)
        (unless (s-matches-p "RESULTS" (match-string 0))
          (replace-match (downcase (match-string 0)) t)
          (setq count (1+ count))))
      (message "Replaced %d occurances" count))))
#+end_src
**** Fix Problematic Hooks
When one of the =org-mode-hook= functions errors, it halts the execution hook. This causes both problems, and a slow down, which is unacceptable. There are two such hooks that are known to cause really weird issues, so let's ignore them
#+begin_src emacs-lisp
(defadvice! shut-up-org-problematic-hooks (orig-fn &rest args)
  :around #'org-fancy-priorities-mode
  :around #'org-superstar-mode
  (ignore-errors (apply orig-fn args)))
#+end_src
*** UI
**** Fonts
Mixed pitch is a terrific invention. =+org-pretty-mode= is just as great. Let's get them to work together.
#+begin_src emacs-lisp
(add-hook! 'org-mode-hook #'+org-pretty-mode #'mixed-pitch-mode)
#+end_src
Let's make the headings larger
#+begin_src emacs-lisp
(custom-set-faces!
  '(outline-1 :weight extra-bold :height 1.17)
  '(outline-2 :weight bold :height 1.15)
  '(outline-3 :weight bold :height 1.12)
  '(outline-4 :weight semi-bold :height 1.09)
  '(outline-5 :weight semi-bold :height 1.06)
  '(outline-6 :weight semi-bold :height 1.03)
  '(outline-8 :weight semi-bold)
  '(outline-9 :weight semi-bold))
#+end_src
Can we do the same for the title?
#+begin_src emacs-lisp
(custom-set-faces!
  '(org-document-title :height 1.2))
#+end_src

If you missed a deadline, you done messed up, and should see the error every time you open your agenda.
#+begin_src emacs-lisp
(setq org-agenda-deadline-faces
      '((1.001 . error)
        (1.0 . org-warning)
        (0.5 . org-upcoming-deadline)
        (0.0 . org-upcoming-distant-deadline)))
#+end_src
Let's make quotes and verses /look/ like quotes and verses, eh?
#+begin_src emacs-lisp
(setq org-fontify-quote-and-verse-blocks t)
#+end_src

=org-hide-emphasis-markers= is nice, but it is a pain when you have to change what's /in/ your emphasis markers. Thankfully, someone made a package that shows these markers when you're inside of it.
#+begin_src emacs-lisp
(use-package! org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src

Org files look great, especially when you do what most people do, enabling thousands of packages to make it even better. However, this comes at a cost of very slow font-locks. After lots of trial and error, people found that you can defer all of it in a batched manner, so let's do that.
#+begin_src emacs-lisp
(defun locally-defer-font-lock ()
  "Set jit-lock defer and stealth, when buffer is over a certain size."
  (when (> (buffer-size) 50000)
    (setq-local jit-lock-defer-time 0.05
                jit-lock-stealth-time 1)))
(add-hook 'org-mode-hook #'locally-defer-font-lock)
#+end_src
This has supposedly caused issues, so if I see anything weird as a result, it goes.
**** Src Blocks
Org does lovely things with =#+begin_src= blocks, like using font-lock for language's major-mode behind the scenes and pulling out the lovely colorful results. By contrast, inline =src_= blocks are somewhat neglected.

I am not the first person to feel this way, thankfully others have [[https://stackoverflow.com/questions/20309842/how-to-syntax-highlight-for-org-mode-inline-source-code-src-lang/28059832][taken to stackexchange]] to voice their desire for inline src fontification. I was going to steal their work, but unfortunately they didn't perform /true/ source code fontification, but simply applied the =org-code= face to the content.

We can do better than that, and we shall! Using ~org-src-font-lock-fontify-block~ we can apply language-appropriate syntax highlighting. Then, continuing on to ={{{results(...)}}}= , it can have the =org-block= face applied to match, and then the value-surrounding constructs hidden by mimicking the behavior of ~prettify-symbols-mode~.
#+begin_src emacs-lisp
(defvar org-prettify-inline-results t
  "Whether to use (ab)use prettify-symbols-mode on {{{results(...)}}}.
Either t or a cons cell of strings which are used as substitutions
for the start and end of inline results, respectively.")

(defvar org-fontify-inline-src-blocks-max-length 200
  "Maximum content length of an inline src block that will be fontified.")

(defun org-fontify-inline-src-blocks (limit)
  "Try to apply `org-fontify-inline-src-blocks-1'."
  (condition-case nil
      (org-fontify-inline-src-blocks-1 limit)
    (error (message "Org mode fontification error in %S at %d"
                    (current-buffer)
                    (line-number-at-pos)))))

(defun org-fontify-inline-src-blocks-1 (limit)
  "Fontify inline src_LANG blocks, from `point' up to LIMIT."
  (let ((case-fold-search t)
        (initial-point (point)))
    (while (re-search-forward "\\_<src_\\([^ \t\n[{]+\\)[{[]?" limit t) ; stolen from `org-element-inline-src-block-parser'
      (let ((beg (match-beginning 0))
            pt
            (lang-beg (match-beginning 1))
            (lang-end (match-end 1)))
        (remove-text-properties beg lang-end '(face nil))
        (font-lock-append-text-property lang-beg lang-end 'face 'org-meta-line)
        (font-lock-append-text-property beg lang-beg 'face 'shadow)
        (font-lock-append-text-property beg lang-end 'face 'org-block)
        (setq pt (goto-char lang-end))
        ;; `org-element--parse-paired-brackets' doesn't take a limit, so to
        ;; prevent it searching the entire rest of the buffer we temporarily
        ;; narrow the active region.
        (save-restriction
          (narrow-to-region beg (min (point-max) limit (+ lang-end org-fontify-inline-src-blocks-max-length)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\[))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (point) 'face 'org-block)
            (setq pt (point)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\{))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (1+ pt) 'face '(org-block shadow))
            (unless (= (1+ pt) (1- (point)))
              (if org-src-fontify-natively
                  (org-src-font-lock-fontify-block (buffer-substring-no-properties lang-beg lang-end) (1+ pt) (1- (point)))
                (font-lock-append-text-property (1+ pt) (1- (point)) 'face 'org-block)))
            (font-lock-append-text-property (1- (point)) (point) 'face '(org-block shadow))
            (setq pt (point))))
        (when (and org-prettify-inline-results (re-search-forward "\\= {{{results(" limit t))
          (font-lock-append-text-property pt (1+ pt) 'face 'org-block)
          (goto-char pt))))
    (when org-prettify-inline-results
      (goto-char initial-point)
      (org-fontify-inline-src-results limit))))

(defun org-fontify-inline-src-results (limit)
  (while (re-search-forward "{{{results(\\(.+?\\))}}}" limit t)
    (remove-list-of-text-properties (match-beginning 0) (point)
                                    '(composition
                                      prettify-symbols-start
                                      prettify-symbols-end))
    (font-lock-append-text-property (match-beginning 0) (match-end 0) 'face 'org-block)
    (let ((start (match-beginning 0)) (end (match-beginning 1)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟨" (car org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))
    (let ((start (match-end 1)) (end (point)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟩" (cdr org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))))

(defun org-fontify-inline-src-blocks-enable ()
  "Add inline src fontification to font-lock in Org.
Must be run as part of `org-font-lock-set-keywords-hook'."
  (setq org-font-lock-extra-keywords
        (append org-font-lock-extra-keywords '((org-fontify-inline-src-blocks)))))

(add-hook 'org-font-lock-set-keywords-hook #'org-fontify-inline-src-blocks-enable)
#+end_src
**** Symbols
Collapsing trees has never been better
#+begin_src emacs-lisp
(after! org-superstar
  (setq org-superstar-headline-bullets-list '("◉" "○" "✸" "✿" "✤" "✜" "◆" "▶")
        ;; org-superstar-headline-bullets-list '("Ⅰ" "Ⅱ" "Ⅲ" "Ⅳ" "Ⅴ" "Ⅵ" "Ⅶ" "Ⅷ" "Ⅸ" "Ⅹ")
        org-superstar-prettify-item-bullets t ))

(setq org-ellipsis " ▾"
      org-hide-leading-stars t
      org-priority-highest ?A
      org-priority-lowest ?E
      org-priority-faces
      '((?A . 'all-the-icons-red)
        (?B . 'all-the-icons-orange)
        (?C . 'all-the-icons-yellow)
        (?D . 'all-the-icons-green)
        (?E . 'all-the-icons-blue)))

#+end_src

Ligatures, need I say more?
#+begin_src emacs-lisp
(appendq! +ligatures-extra-symbols
          `(:checkbox      "☐"
            :pending       "◼"
            :checkedbox    "☑"
            :list_property "∷"
            :em_dash       "—"
            :ellipses      "…"
            :arrow_right   "→"
            :arrow_left    "←"
            :title         "𝙏"
            :subtitle      "𝙩"
            :author        "𝘼"
            :date          "𝘿"
            :property      "☸"
            :options       "⌥"
            :startup       "⏻"
            :macro         "𝓜"
            :html_head     "🅷"
            :html          "🅗"
            :latex_class   "🄻"
            :latex_header  "🅻"
            :beamer_header "🅑"
            :latex         "🅛"
            :attr_latex    "🄛"
            :attr_html     "🄗"
            :attr_org      "⒪"
            :begin_quote   "❝"
            :end_quote     "❞"
            :caption       "☰"
            :header        "›"
            :results       "🠶"
            :begin_export  "⏩"
            :end_export    "⏪"
            :properties    "⚙"
            :end           "∎"
            :priority_a   ,(propertize "⚑" 'face 'all-the-icons-red)
            :priority_b   ,(propertize "⬆" 'face 'all-the-icons-orange)
            :priority_c   ,(propertize "■" 'face 'all-the-icons-yellow)
            :priority_d   ,(propertize "⬇" 'face 'all-the-icons-green)
            :priority_e   ,(propertize "❓" 'face 'all-the-icons-blue)))
(set-ligatures! 'org-mode
  :merge t
  :checkbox      "[ ]"
  :pending       "[-]"
  :checkedbox    "[X]"
  :list_property "::"
  :em_dash       "---"
  :ellipsis      "..."
  :arrow_right   "->"
  :arrow_left    "<-"
  :title         "#+title:"
  :subtitle      "#+subtitle:"
  :author        "#+author:"
  :date          "#+date:"
  :property      "#+property:"
  :options       "#+options:"
  :startup       "#+startup:"
  :macro         "#+macro:"
  :html_head     "#+html_head:"
  :html          "#+html:"
  :latex_class   "#+latex_class:"
  :latex_header  "#+latex_header:"
  :beamer_header "#+beamer_header:"
  :latex         "#+latex:"
  :attr_latex    "#+attr_latex:"
  :attr_html     "#+attr_html:"
  :attr_org      "#+attr_org:"
  :begin_quote   "#+begin_quote"
  :end_quote     "#+end_quote"
  :caption       "#+caption:"
  :header        "#+header:"
  :begin_export  "#+begin_export"
  :end_export    "#+end_export"
  :results       "#+RESULTS:"
  :property      ":PROPERTIES:"
  :end           ":END:"
  :priority_a    "[#A]"
  :priority_b    "[#B]"
  :priority_c    "[#C]"
  :priority_d    "[#D]"
  :priority_e    "[#E]")
(plist-put +ligatures-extra-symbols :name "⁍")
#+end_src
**** \LaTeX Fragments
***** Prettier Highlighting
First off, let's make those fragments look as good as we can.
#+begin_src emacs-lisp
(setq org-highlight-latex-and-related '(native script entities))
#+end_src
Sadly, using =native= highlighting adds the =org-block= face, which looks pretty bad, especially when previews for the fragments are used.

Ideally =org-src-font-lock-fontify-block= wouldn't add the =org-block= face, but we can avoid advising that entire function by just adding another face with =:inherit= default which will override the background color.

Inspecting =org-do-latex-and-related= shows that ="latex"= is the language argument passed, and so we can override the background as discussed above.
#+begin_src emacs-lisp
(add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t)))
#+end_src
***** More eager rendering
What's better than syntax-highlighted \LaTeX? /Rendered/ \LaTeX, obviously, which is something we can easily get with =org-fragtog=
#+begin_src emacs-lisp
(use-package! org-fragtog
  :hook (org-mode . org-fragtog-mode))
#+end_src
***** Prettier rendering
It's nice to customize the look of LaTeX fragments so they fit better in the
text --- like this \(\sqrt{\beta^2+3}-\sum_{\phi=1}^\infty \frac{x^\phi-1}{\Gamma(a)}\).
Let's start by adding a sans font. I'd also like to use some of the
functionality from =bmc-maths=, so we'll load that too.
#+begin_src emacs-lisp
(setq org-format-latex-header "\\documentclass{article}
\\usepackage[usenames]{xcolor}

\\usepackage[T1]{fontenc}

\\usepackage{booktabs}

\\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\\setlength{\\textwidth}{\\paperwidth}
\\addtolength{\\textwidth}{-3cm}
\\setlength{\\oddsidemargin}{1.5cm}
\\addtolength{\\oddsidemargin}{-2.54cm}
\\setlength{\\evensidemargin}{\\oddsidemargin}
\\setlength{\\textheight}{\\paperheight}
\\addtolength{\\textheight}{-\\headheight}
\\addtolength{\\textheight}{-\\headsep}
\\addtolength{\\textheight}{-\\footskip}
\\addtolength{\\textheight}{-3cm}
\\setlength{\\topmargin}{1.5cm}
\\addtolength{\\topmargin}{-2.54cm}
")
#+end_src
If we're already making everything run slower for aesthetics, why not make the background face transparent?
#+begin_src emacs-lisp
(setq org-format-latex-options
      (plist-put org-format-latex-options :background "Transparent"))
#+end_src
***** Rendering Benchmarking
Lots of people have done benchmarks for different \LaTeX engines, and found that =dvipng= is the fastest, and is what we'll therefore use for previews. However, this is not the highest quality, so we'll use other methods for when we export.
**** Org Plot
We can take some of the colors from our current doom theme, and inject them into the =org-plot= variables.
#+begin_src emacs-lisp
(after! org-plot
  (defun org-plot/generate-theme (_type)
    "Use the current Doom theme colors to generate a GnuPlot preamble."
    (format "
fgt = \"textcolor rgb '%s'\" # foreground text
fgat = \"textcolor rgb '%s'\" # foreground alt text
fgl = \"linecolor rgb '%s'\" # foreground line
fgal = \"linecolor rgb '%s'\" # foreground alt line

# foreground colors
set border lc rgb '%s'
# change text colors of  tics
set xtics @fgt
set ytics @fgt
# change text colors of labels
set title @fgt
set xlabel @fgt
set ylabel @fgt
# change a text color of key
set key @fgt

# line styles
set linetype 1 lw 2 lc rgb '%s' # red
set linetype 2 lw 2 lc rgb '%s' # blue
set linetype 3 lw 2 lc rgb '%s' # green
set linetype 4 lw 2 lc rgb '%s' # magenta
set linetype 5 lw 2 lc rgb '%s' # orange
set linetype 6 lw 2 lc rgb '%s' # yellow
set linetype 7 lw 2 lc rgb '%s' # teal
set linetype 8 lw 2 lc rgb '%s' # violet

# palette
set palette maxcolors 8
set palette defined ( 0 '%s',\
1 '%s',\
2 '%s',\
3 '%s',\
4 '%s',\
5 '%s',\
6 '%s',\
7 '%s' )
"
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            ;; colors
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ;; duplicated
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ))
  (defun org-plot/gnuplot-term-properties (_type)
    (format "background rgb '%s' size 1050,650"
            (doom-color 'bg)))
  (setq org-plot/gnuplot-script-preamble #'org-plot/generate-theme)
  (setq org-plot/gnuplot-term-extra #'org-plot/gnuplot-term-properties))
#+end_src
*** TODO Exporting
*** Babel
Doom automatically pulls in ob-async, but it doesn't use it. By using it, we could get a great boost to performance. This does come with a few slight caveats: ob-async doesn't support the =:session= parameter, adds a fixed execution delay, and doesn't work super well with =emacs-lisp=. This code fixes most of that.
#+begin_src emacs-lisp
(add-transient-hook! #'org-babel-execute-src-block
  (require 'ob-async))

(defvar org-babel-auto-async-languages '()
  "Babel languages which should be executed asyncronously by default.")

(defadvice! org-babel-get-src-block-info-eager-async-a (orig-fn &optional light datum)
  "Eagarly add an :async parameter to the src information, unless it seems problematic.
This only acts o languages in `org-babel-auto-async-languages'.
Not added when either:
+ session is not \"none\"
+ :sync is set"
  :around #'org-babel-get-src-block-info
  (let ((result (funcall orig-fn light datum)))
    (when (and (string= "none" (cdr (assoc :session (caddr result))))
               (member (car result) org-babel-auto-async-languages)
               (not (assoc :async (caddr result))) ; don't duplicate
               (not (assoc :sync (caddr result))))
      (push '(:async) (caddr result)))
    result))


#+end_src
** TODO \LaTeX
** Graphviz
#+begin_src emacs-lisp
(use-package! graphviz-dot-mode
   :commands graphviz-dot-mode
    :mode ("\\.dot\\'" "\\.gz\\'")
    :init
    (after! org
        (setcdr (assoc "dot" org-src-lang-modes)
                'graphviz-dot)))

(use-package! company-graphviz-dot
   :after graphviz-dot-mode)
#+end_src
** Shells
Settings for the various shells and terminal emulators within Emacs.
+ 'shell-file-name' -- sets the shell to be used in M-x shell, M-x term, M-x ansi-term and M-x vterm.
+ 'eshell-aliases-file' -- sets an aliases file for the eshell.

#+begin_src emacs-lisp
(setq shell-file-name "/bin/zsh"
      eshell-aliases-file "~/.config/doom/aliases"
      eshell-history-size 5000
      eshell-buffer-maximum-lines 5000
      eshell-hist-ignoredups t
      eshell-scroll-to-bottom-on-input t
      eshell-destroy-buffer-when-process-dies t
      eshell-visual-commands'("bash" "htop" "ssh" "zsh")
      vterm-max-scrollback 5000)
(map! :leader
      :desc "Counsel eshell history"
      "e h" #'counsel-esh-history)
#+end_src
** Snippets
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :comments no
:END:
*** Latex mode
File template
#+begin_src snippet
# -*- mode: snippet -*-
# name: LaTeX template
# --
\documentclass${1:[${2:opt1,...}]}{`(tec/yas-latex-get-class-choice)`}

\title{${3:`(s-titleized-words (file-name-base (or buffer-file-name "new buffer")))`}}
\author{${4:`(user-full-name)`}}
\date{${5:`(format-time-string "%Y-%m-%d")`}}
`(if (tec/yas-latex-preamble-if) tec/yas-latex-template-preamble "")`
\begin{document}

\maketitle

$0

\end{document}
#+end_src

Deliminators
#+begin_src snippet
# name: _deliminators
# --
\left`(tec/tex-open-delim-from-char)` `%`$1 \right`(tec/tex-close-delim-from-char)` $0

#+end_src

Aligned equals
#+begin_src snippet
# key: ==
# name: aligned equals
# --
&=
#+end_src

Begin alias
#+begin_src snippet
# -*- mode: snippet -*-
# name: begin-alias
# key: beg
# type: command
# --
(doom-snippets-expand :name "begin")
#+end_src

Cases
#+begin_src snippet
# -*- mode: snippet -*-
# key: cs
# name: cases
# group: math
# condition: (texmathp)
# --
\begin{cases}
  `%`$1
\end{cases}$0
#+end_src

Code
#+begin_src snippet
# -*- mode: snippet -*-
# name: code
# --
\begin{minted}{${1:language}}
${0:`%`}
\end{minted}

#+end_src

Corollary
#+begin_src snippet
# -*- mode: snippet -*-
# name: corollary
# key: clr
# group: theorems
# --
\begin{corollary}${1:[${2:name}]}
  `%`$0
\end{corollary}
#+end_src

Definition
#+begin_src snippet
# -*- mode: snippet -*-
# name: definition
# key: def
# group: theorems
# --
\begin{definition}${1:[${2:name}]}
  `%`$0
\end{definition}
#+end_src

Deliminators
#+begin_src snippet
# -*- mode: snippet -*-
# name: deliminators
# key: @
# condition: (texmathp)
# type: command
# --
(tec/get-open-delim-char)
(yas-expand-snippet (yas-lookup-snippet "_deliminators" 'latex-mode))
#+end_src

Deliminators angle
#+begin_src snippet
# -*- mode: snippet -*-
# name: deliminators - angle <>
# key: <
# condition: (texmathp)
# type: command
# --
(setq tec/tex-last-delim-char ?\<)
(setq tec/tex-delim-dot-second nil)
(tec/tex-delim-yas-expand)
#+end_src

Deliminators bracket
#+begin_src snippet
# -*- mode: snippet -*-
# name: deliminators - bracket []
# key: [
# condition: (texmathp)
# type: command
# --
(setq tec/tex-last-delim-char ?\[)
(setq tec/tex-delim-dot-second nil)
(tec/tex-delim-yas-expand)
#+end_src

Deliminators curly
#+begin_src snippet
# -*- mode: snippet -*-
# name: deliminators - curley {}
# key: {
# condition: (texmathp)
# type: command
# --
(setq tec/tex-last-delim-char ?\{)
(setq tec/tex-delim-dot-second nil)
(tec/tex-delim-yas-expand)

#+end_src

Deliminators parenthesis
#+begin_src snippet
# -*- mode: snippet -*-
# name: deliminators - paren ()
# key: (
# condition: (texmathp)
# type: command
# --
(setq tec/tex-last-delim-char ?\()
(setq tec/tex-delim-dot-second nil)
(tec/tex-delim-yas-expand)
#+end_src

Enumerate
#+begin_src snippet
# -*- mode: snippet -*-
# name: enumerate
# key: en
# --
\begin{enumerate}
`(if % % "  \\item ")`$0
\end{enumerate}
#+end_src

Example
#+begin_src snippet
# -*- mode: snippet -*-
# name: example
# key: eg
# group: theorems
# --
\begin{example}${1:[${2:name}]}
  `%`$0
\end{example}
#+end_src

Frac short
#+begin_src snippet
# -*- mode: snippet -*-
# key: /
# name: frac-short
# group: math
# condition: (texmathp)
# --
\frac{${1:`(or % "")`}}{$2}$0
#+end_src

Int ^
#+begin_src snippet
# -*- mode: snippet -*-
# key: int
# name: int_^
# --
\int${1:$(when (> (length yas-text) 0) "_")
}${1:$(when (> (length yas-text) 1) "{")
}${1:left}${1:$(when (> (length yas-text) 1) "}")
}${2:$(when (> (length yas-text) 0) "^")
}${2:$(when (> (length yas-text) 1) "{")
}${2:right}${2:$(when (> (length yas-text) 1) "}")} $0
#+end_src

Itemize
#+begin_src snippet
# -*- mode: snippet -*-
# name: itemize
# key: it
# uuid: it
# --
\begin{itemize}
`(if % % "  \\item ")`$0
\end{itemize}
#+end_src

Lemma
#+begin_src snippet
# -*- mode: snippet -*-
# name: lemma
# key: lmm
# group: theorems
# --
\begin{lemma}${1:[${2:name}]}
  `%`$0
\end{lemma}
#+end_src

Lim
#+begin_src snippet
# -*- mode: snippet -*-
# name: lim
# key: lim
# --
\lim_{${1:n} \to ${2:\infty}} $0
#+end_src

Mathclap
#+begin_src snippet
# -*- mode: snippet -*-
# key: mc
# name: mathclap
# group: math
# condition: (texmathp)
# --
\mathclap{`%`$1}$0
#+end_src

Prod ^
#+begin_src snippet
# key: prod
# name: prod_^
# --
\prod${1:$(when (> (length yas-text) 0) "_")
}${1:$(when (> (length yas-text) 1) "{")
}${1:i=1}${1:$(when (> (length yas-text) 1) "}")
}${2:$(when (> (length yas-text) 0) "^")
}${2:$(when (> (length yas-text) 1) "{")
}${2:n}${2:$(when (> (length yas-text) 1) "}")} $0
#+end_src

Proof
#+begin_src snippet
# -*- mode: snippet -*-
# name: proof
# key: prf
# group: theorems
# --
\begin{proof}${1:[${2:name}]}
  `%`$0
\end{proof}
#+end_src

Remark
#+begin_src snippet
# -*- mode: snippet -*-
# name: remark
# key: rmk
# group: theorems
# --
\begin{remark}${1:[${2:name}]}
  `%`$0
\end{remark}
#+end_src

Sum ^
#+begin_src snippet
# key: sum
# name: sum_^
# --
\sum${1:$(when (> (length yas-text) 0) "_")
}${1:$(when (> (length yas-text) 1) "{")
}${1:i=1}${1:$(when (> (length yas-text) 1) "}")
}${2:$(when (> (length yas-text) 0) "^")
}${2:$(when (> (length yas-text) 1) "{")
}${2:n}${2:$(when (> (length yas-text) 1) "}")} $0
#+end_src

Theorem
#+begin_src snippet
# -*- mode: snippet -*-
# name: theorem
# key: thm
# group: theorems
# --
\begin{theorem}${1:[${2:name}]}
  `%`$0
\end{theorem}
#+end_src

*** Markdown mode
File template
#+begin_src snippet
# -*- mode: snippet -*-
# name: Org template
# --
# ${1:`(s-titleized-words (file-name-base (or buffer-file-name "new buffer")))`}

$0
#+end_src

*** Org mode
File template
#+begin_src snippet
# -*- mode: snippet -*-
# name: Org template
# --
,#+title: ${1:`(s-titleized-words (replace-regexp-in-string "^[0-9]\\{4\\}-[0-9][0-9]-[0-9][0-9]-" "" (file-name-base (or buffer-file-name "new buffer"))))`}
,#+author: ${2:`(user-full-name)`}
,#+date: ${3:`(format-time-string "%Y-%m-%d")`}

$0
#+end_src

Display maths
#+begin_src snippet
# -*- mode: snippet -*-
# name: display math
# key: M
# condition: t
# expand-env: ((yas-after-exit-snippet-hook (lambda () (org-edit-latex-fragment) (evil-insert-state) (insert "\n  \n") (left-char))))
# --
\\[`%`$0\\]
#+end_src

Elisp source
#+begin_src snippet
# -*- mode: snippet -*-
# name: elisp src
# uuid: src_elisp
# key: <el
# condition: t
# expand-env: ((yas-after-exit-snippet-hook #'org-edit-src-code))
# --
,#+begin_src emacs-lisp
`%`$0
,#+end_src
#+end_src

Global property
#+begin_src snippet
# -*- mode: snippet -*-
# name: Global property
# key: #+p
# condition: (> 20 (line-number-at-pos))
# --
,#+property: $0
#+end_src

Header argument dir
#+begin_src snippet
# -*- mode: snippet -*-
# name: Header arg - dir
# key: d
# condition: (+yas/org-src-header-p)
# --
:dir `(file-relative-name (read-directory-name "Working directory: "))` $0
#+end_src

Header argument eval
#+begin_src snippet
# -*- mode: snippet -*-
# name: Header arg - eval
# key: v
# condition: (+yas/org-src-header-p)
# --
`(let ((out (+yas/org-prompt-header-arg :eval "Evaluate: " '("no" "query" "no-export" "query-export")))) (if out (concat ":eval " out " ") ""))`$0
#+end_src

Header argument export
#+begin_src snippet
# -*- mode: snippet -*-
# name: Header arg - export
# key: e
# condition: (+yas/org-src-header-p)
# --
`(let ((out (+yas/org-prompt-header-arg :exports "Exports: " '("code" "results" "both" "none")))) (if out (concat ":exports " out " ") ""))`$0
#+end_src

Header argument file
#+begin_src snippet
# -*- mode: snippet -*-
# name: Header arg - file
# key: f
# condition: (+yas/org-src-header-p)
# --
:file $0
#+end_src

Header argument graphics
#+begin_src snippet
# -*- mode: snippet -*-
# name: Header arg - graphics
# key: g
# condition: (+yas/org-src-header-p)
# --
:results file graphics $0
#+end_src

Header argument height
#+begin_src snippet
# -*- mode: snippet -*-
# name: Header arg - height
# key: H
# condition: (+yas/org-src-header-p)
# --
:height $0
#+end_src

Header argument noweb
#+begin_src snippet
# -*- mode: snippet -*-
# name: Header arg - noweb
# key: n
# condition: (+yas/org-src-header-p)
# --
`(let ((out (+yas/org-prompt-header-arg :noweb "Evaluate: " '("no" "yes" "tangle" "no-export" "strip-export" "eval")))) (if out (concat ":noweb " out " ") ""))`$0
#+end_src

Header argument output
#+begin_src snippet
# -*- mode: snippet -*-
# name: Header arg - output
# key: o
# condition: (+yas/org-src-header-p)
# --
:results output $0
#+end_src

Header argument results
#+begin_src snippet
# -*- mode: snippet -*-
# name: Header arg - results
# key: r
# condition: (+yas/org-src-header-p)
# --
`(let ((out
(string-trim-right
 (concat
  (+yas/org-prompt-header-arg :results "Result collection: " '("value " "output "))
  (+yas/org-prompt-header-arg :results "Results type: " '("table " "vector " "list " "verbatim " "file "))
  (+yas/org-prompt-header-arg :results "Results format: " '("code " "drawer " "html " "latex " "link " "graphics " "org " "pp " "raw "))
  (+yas/org-prompt-header-arg :results "Result output: " '("silent " "replace " "append " "prepend "))))))
  (if (string= out "") ""
  (concat ":results " out " ")))
`$0
#+end_src

Header argument session
#+begin_src snippet
# -*- mode: snippet -*-
# name: Header arg - session
# key: s
# condition: (+yas/org-src-header-p)
# --
:session "${1:`(file-name-base (or (buffer-file-name) "unnnamed"))`-session}" $0
#+end_src

Header argument silent
#+begin_src snippet
# -*- mode: snippet -*-
# name: Header arg - silent
# key: S
# condition: (+yas/org-src-header-p)
# --
:results silent $0
#+end_src

Header argument tangle
#+begin_src snippet
# -*- mode: snippet -*-
# name: Header arg - tangle
# key: t
# condition: (+yas/org-src-header-p)
# --
:tangle $0
#+end_src

Header argument width
#+begin_src snippet
# -*- mode: snippet -*-
# name: Header arg - width
# key: W
# condition: (+yas/org-src-header-p)
# --
:width $0
#+end_src

Header argument wrap
#+begin_src snippet
# -*- mode: snippet -*-
# name: Header arg - wrap
# key: w
# condition: (+yas/org-src-header-p)
# --
`(let ((out (+yas/org-prompt-header-arg :noweb "Wrap: " '("example" "export" "comment" "src")))) (if out (concat ":wrap " out " ") ""))`$0
#+end_src

Inline math
#+begin_src snippet
# -*- mode: snippet -*-
# name: inline math
# key: m
# condition: t
# expand-env: ((yas-after-exit-snippet-hook (lambda () (org-edit-latex-fragment) (evil-insert-state) (goto-char 3))))
# --
\\(`%`$0\\)
#+end_src

Property header arguments
#+begin_src snippet
# -*- mode: snippet -*-
# name: Property - header arg
# key: h
# condition: (or (looking-back "^#\\+PROPERTY:.*" (line-beginning-position)) (looking-back "^#\\+property:.*" (line-beginning-position)))
# --
header-args:${1:`(or (+yas/org-most-common-no-property-lang) "?")`} $0
#+end_src

Python source
#+begin_src snippet
# -*- mode: snippet -*-
# name: python src
# uuid: src_python
# key: <py
# condition: t
# expand-env: ((yas-after-exit-snippet-hook #'org-edit-src-code))
# --
,#+begin_src python
`%`$0
,#+end_src
#+end_src

Source
#+begin_src snippet
# -*- mode: snippet -*-
# name: #+begin_src
# uuid: src
# key: src
# --
,#+begin_src ${1:`(or (+yas/org-last-src-lang) "?")`}
`%`$0
,#+end_src
#+end_src
* TODO Application Config
This section is primarily about setting up emacs to work for something /besides/ programming.
** TODO MPD
** TODO Email
** TODO IRC
** TODO Hangouts?
** TODO PDF
** Dictionary
Let's start off by loading =lexic=, then integrate it into all of our pre-existing functionality so it feels nice to use.
#+begin_src emacs-lisp
(use-package! lexic
  :commands lexic-search lexic-list-dictionary
  :config
  (map! :map lexic-mode-map
        :n "q" #'lexic-return-from-lexic
        :nv "RET" #'lexic-search-word-at-point
        :n "a" #'outline-show-all
        :n "h" (cmd! (outline-hide-sublevels 3))
        :n "o" #'lexic-toggle-entry
        :n "n" #'lexic-next-entry
        :n "N" (cmd! (lexic-next-entry t))
        :n "p" #'lexic-previous-entry
        :n "P" (cmd! (lexic-previous-entry t))
        :n "E" (cmd! (lexic-return-from-lexic) ; expand
                     (switch-to-buffer (lexic-get-buffer)))
        :n "M" (cmd! (lexic-return-from-lexic) ; minimise
                     (lexic-goto-lexic))
        :n "C-p" #'lexic-search-history-backwards
        :n "C-n" #'lexic-search-history-forwards
        :n "/" (cmd! (call-interactively #'lexic-search))))
#+end_src

We need to override =wordnet= for this to work correctly
#+begin_src emacs-lisp
(defadvice! +lookup/dictionary-definition-lexic (identifier &optional arg)
   "Look up the definition of the word at point (or selection) using lexic-search."
    :override #'+lookup/dictionary-definition
     (interactive
            (list (or (doom-thing-at-point-or-region 'word)
                      (read-string "Look up in dictionary: "))
                  current-prefix-arg))
      (lexic-search identifier nil nil t))
#+end_src
** TODO RSS
